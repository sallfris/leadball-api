<?php
/**
 * ObjectSerializer
 *
 * PHP version 5
 *
 * @category Class
 * @package  sallfris\Leadball\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Swagger Leadball messaging service - OpenAPI 3.0
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.25.5
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.41
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace sallfris\Leadball\Client;

/**
 * ObjectSerializer Class Doc Comment
 *
 * @category Class
 * @package  sallfris\Leadball\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ObjectSerializer
{
    /**
     * Serialize data
     *
     * @param mixed $data the data to serialize
     * @param string $format the format of the Swagger type of the data
     *
     * @return string|object|array serialized form of $data
     */
    public static function sanitizeForSerialization($data, $format = null)
    {
        if (is_scalar($data) || null === $data) {
            return $data;
        }
        
        if ($data instanceof \DateTime) {
            return ($format === 'date') ? $data->format('Y-m-d') : $data->format(\DateTime::ATOM);
        }
        
        if (is_array($data)) {
            foreach ($data as $property => $value) {
                $data[$property] = self::sanitizeForSerialization($value);
            }
            return $data;
        }
        
        if (is_object($data)) {
            $values = [];
            foreach ($data::swaggerTypes() as $property => $swaggerType) {
                $getter = $data::getters()[$property];
                $value = $data->$getter();
                if ($value !== null
                    && !in_array(
                        $swaggerType,
                        ['DateTime', 'bool', 'boolean', 'byte', 'double', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'],
                        true
                    )
                    && method_exists($swaggerType, 'getAllowableEnumValues')
                    && !in_array($value, $swaggerType::getAllowableEnumValues())) {
                    $imploded = implode("', '", $swaggerType::getAllowableEnumValues());
                    throw new \InvalidArgumentException(
                        "Invalid value for enum '$swaggerType', must be one of: '$imploded'"
                    );
                }
                if ($value !== null) {
                    $values[$data::attributeMap()[$property]] = self::sanitizeForSerialization(
                        $value,
                        $swaggerType,
                    );
                }
            }
            return (object)$values;
        }
        
        return (string)$data;
    }
    
    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param string $filename filename to be sanitized
     *
     * @return string the sanitized filename
     */
    public static function sanitizeFilename($filename)
    {
        if (preg_match("/.*[\/\\\\](.*)$/", $filename, $match)) {
            return $match[1];
        }
        
        return $filename;
    }
    
    /**
     * Take value and turn it into a string suitable for inclusion in
     * the path, by url-encoding.
     *
     * @param string $value a string which will be part of the path
     *
     * @return string the serialized object
     */
    public static function toPathValue($value)
    {
        return rawurlencode(self::toString($value));
    }
    
    /**
     * Take value and turn it into a string suitable for inclusion in
     * the query, by imploding comma-separated if it's an object.
     * If it's a string, pass through unchanged. It will be url-encoded
     * later.
     *
     * @param string[]|string|\DateTime $object an object to be serialized to a string
     * @param string|null $format the format of the parameter
     *
     * @return string the serialized object
     */
    public static function toQueryValue($object, $format = null)
    {
        if (is_array($object)) {
            return implode(',', $object);
        }
        
        return self::toString($object, $format);
    }
    
    /**
     * Take value and turn it into a string suitable for inclusion in
     * the header. If it's a string, pass through unchanged
     * If it's a datetime object, format it in RFC3339
     *
     * @param string $value a string which will be part of the header
     *
     * @return string the header string
     */
    public static function toHeaderValue($value)
    {
        return self::toString($value);
    }
    
    /**
     * Take value and turn it into a string suitable for inclusion in
     * the http body (form parameter). If it's a string, pass through unchanged
     * If it's a datetime object, format it in RFC3339
     *
     * @param string|\SplFileObject $value the value of the form parameter
     *
     * @return string the form string
     */
    public static function toFormValue($value)
    {
        if ($value instanceof \SplFileObject) {
            return $value->getRealPath();
        }
        
        return self::toString($value);
    }
    
    /**
     * Take value and turn it into a string suitable for inclusion in
     * the parameter. If it's a string, pass through unchanged
     * If it's a datetime object, format it in RFC3339
     * If it's a date, format it in Y-m-d
     *
     * @param string|\DateTime $value the value of the parameter
     * @param string|null $format the format of the parameter
     *
     * @return string the header string
     */
    public static function toString($value, $format = null)
    {
        if ($value instanceof \DateTime) {
            return ($format === 'date') ? $value->format('Y-m-d') : $value->format(\DateTime::ATOM);
        }
        
        return $value;
    }
    
    /**
     * Serialize an array to a string.
     *
     * @param array $collection collection to serialize to a string
     * @param string $collectionFormat the format use for serialization (csv,
     * ssv, tsv, pipes, multi)
     * @param bool $allowCollectionFormatMulti allow collection format to be a multidimensional array
     *
     * @return string
     */
    public static function serializeCollection(array $collection, $collectionFormat, $allowCollectionFormatMulti = false)
    {
        if ($allowCollectionFormatMulti && ('multi' === $collectionFormat)) {
            // http_build_query() almost does the job for us. We just
            // need to fix the result of multidimensional arrays.
            return preg_replace('/%5B\d+%5D=/', '=', http_build_query($collection, '', '&'));
        }
        switch ($collectionFormat) {
            case 'pipes':
                return implode('|', $collection);
            
            case 'tsv':
                return implode("\t", $collection);
            
            case 'ssv':
                return implode(' ', $collection);
            
            case 'csv':
                // Deliberate fall through. CSV is default format.
            default:
                return implode(',', $collection);
        }
    }
    
    /**
     * Deserialize a JSON string into an object
     *
     * @param mixed $data object or primitive to be deserialized
     * @param string $class class name is passed as a string
     * @param array $httpHeaders HTTP headers
     * @return object|array|null an single or an array of $class instances
     * @throws \Exception
     */
    public static function deserialize($data, $class, $httpHeaders = [])
    {
        if (null === $data || $class === '\DateTime') {
            if (!empty($data)) {
                return new \DateTime($data);
            }
    
            return null;
        }
        $selfMethod = null;
        
        if (substr($class, 0, 4) === 'map[') { // for associative array e.g. map[string,int]
            $selfMethod = 'deserializeMap';
        }
        
        if (strcasecmp(substr($class, -2), '[]') === 0) {
            $selfMethod = 'deserializeArray';
        }
        
        if (method_exists($class, 'getAllowableEnumValues')) {
            $selfMethod = 'getClassAllowableEnumValues';
        }
        
        if ($class === 'object') {
            return (array) $data;
        }
        
        if (in_array(
            $class,
            ['DateTime', 'bool', 'boolean', 'byte', 'double', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'],
            true
        )) {
            $selfMethod = 'getVar';
        }
        
        $value = $class;
        if ($class === '\SplFileObject') {
            $selfMethod = 'deserializeSplFileObject';
            $value = $httpHeaders;
        }
        
        if($selfMethod){
            return self::$selfMethod($value, $data);
        }
        
       
        
        $discriminator = $class::DISCRIMINATOR;
        if (!empty($discriminator) && isset($data->{$discriminator}) && is_string($data->{$discriminator})) {
            $subclass = '{{invokerPackage}}\Model\\' . $data->{$discriminator};
            if (is_subclass_of($subclass, $class)) {
                $class = $subclass;
            }
        }
        $instance = new $class();
        foreach ($instance::swaggerTypes() as $property => $type) {
            $propertySetter = $instance::setters()[$property];
            
            if (!isset($propertySetter) || !isset($data->{$instance::attributeMap()[$property]})) {
                continue;
            }
            
            $propertyValue = $data->{$instance::attributeMap()[$property]};
            if (isset($propertyValue)) {
                $instance->$propertySetter(self::deserialize($propertyValue, $type, null));
            }
        }
        return $instance;
    }
    
    /**
     * @param string $class
     * @param $data
     * @return array
     * @throws \Exception
     */
    private static function deserializeMap(string $class, $data): array
    {
        $inner = substr($class, 4, -1);
        $deserialized = [];
        if (strrpos($inner, ",") !== false) {
            $subClassArray = explode(',', $inner, 2);
            $subClass = $subClassArray[1];
            foreach ($data as $key => $value) {
                $deserialized[$key] = self::deserialize($value, $subClass, null);
            }
        }
        return $deserialized;
    }
    
    /**
     * @param string $class
     * @param $data
     * @return array
     * @throws \Exception
     */
    private static function deserializeArray(string $class, $data): array
    {
        $subClass = substr($class, 0, -2);
        $values = [];
        foreach ($data as $value) {
            $values[] = self::deserialize($value, $subClass, null);
        }
        return $values;
    }
    
    /**
     * @param array|null $httpHeaders
     * @param $match
     * @param \Psr\Http\Message\StreamInterface $data
     * @return \SplFileObject
     */
    private static function deserializeSplFileObject(?array $httpHeaders, \Psr\Http\Message\StreamInterface $data): \SplFileObject
    {
        /** @var \Psr\Http\Message\StreamInterface $data */
        
        // determine file name
        if (array_key_exists('Content-Disposition', $httpHeaders) &&
            preg_match(
                '/inline; filename=[\'"]?([^\'"\s]+)[\'"]?$/i',
                $httpHeaders['Content-Disposition'],
                $match
            )) {
            $filename = Configuration::getDefaultConfiguration()->getTempFolderPath(
                ) . DIRECTORY_SEPARATOR . self::sanitizeFilename($match[1]);
        } else {
            $filename = tempnam(Configuration::getDefaultConfiguration()->getTempFolderPath(), '');
        }
        
        $file = fopen($filename, 'wb');
        while ($chunk = $data->read(200)) {
            fwrite($file, $chunk);
        }
        fclose($file);
        
        return new \SplFileObject($filename, 'r');
    }
    
    /**
     * @param $data
     * @param string|object $class
     * @return mixed
     */
    private static function getClassAllowableEnumValues($class, $data)
    {
        if (!in_array($data, $class::getAllowableEnumValues())) {
            $imploded = implode("', '", $class::getAllowableEnumValues());
            throw new \InvalidArgumentException("Invalid value for enum '$class', must be one of: '$imploded'");
        }
        return $data;
    }
    
    /**
     * @param $data
     * @param string $class
     * @return mixed
     */
    private static function getVar(string $class, $data)
    {
        settype($data, $class);
        return $data;
    }
}
